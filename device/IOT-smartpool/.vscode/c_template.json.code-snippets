{
	"C file template": {
		"prefix": "cfile",
		"description": "C file template with auto include header file",
		"body": [
			"/**",
            "* @file $TM_FILENAME",
            "*",
			"* @brief $1",
			"*",
            "* COPYRIGHT NOTICE: (c) $CURRENT_YEAR",
            "* All rights reserved.",
            "*/",
			"",
			"//--------------------------------- INCLUDES ----------------------------------",
			"#include \"${TM_FILENAME/[\\.]c/.h/}\"",
			"",
			"//---------------------------------- MACROS -----------------------------------",
			"",
			"//-------------------------------- DATA TYPES ---------------------------------",
			"",
			"//---------------------- PRIVATE FUNCTION PROTOTYPES --------------------------",
			"",
			"//------------------------- STATIC DATA & CONSTANTS ---------------------------",
			"",
			"//------------------------------- GLOBAL DATA ---------------------------------",
			"",
			"//------------------------------ PUBLIC FUNCTIONS -----------------------------",
			"",
			"//---------------------------- PRIVATE FUNCTIONS ------------------------------",
			"",
			"//---------------------------- INTERRUPT HANDLERS -----------------------------",
			"",
			"",
			""
		]
	},
	"Header file template": {
		"prefix": "hfile",
		"description": "Header file template with include guards",
		"body": [
			"/**",
            "* @file $TM_FILENAME",
            "*",
			"* @brief See the source file.",
            "* ",
            "* COPYRIGHT NOTICE: (c) $CURRENT_YEAR",
            "* All rights reserved.",
            "*/",
			"",
			"#ifndef __${TM_FILENAME/^([^\\.]*)\\..*$/${1:/upcase}/}_${TM_FILENAME/^.*\\.([^\\.]*)$/${1:/upcase}/}__",
			"#define __${TM_FILENAME/^([^\\.]*)\\..*$/${1:/upcase}/}_${TM_FILENAME/^.*\\.([^\\.]*)$/${1:/upcase}/}__",
			"",
			"#ifdef __cplusplus",
			"extern \"C\" {",
			"#endif",
			"",
			"//--------------------------------- INCLUDES ----------------------------------",
			"",
			"//---------------------------------- MACROS -----------------------------------",
            "",
            "//-------------------------------- DATA TYPES ---------------------------------",
            "",
            "//---------------------- PUBLIC FUNCTION PROTOTYPES --------------------------",
            "",
			"",
			"",
			"#ifdef __cplusplus",
			"}",
			"#endif",

			"",
			"#endif // __${TM_FILENAME/^([^\\.]*)\\..*$/${1:/upcase}/}_${TM_FILENAME/^.*\\.([^\\.]*)$/${1:/upcase}/}__",
			""
		]
	},
	"printf": {
		"prefix": "printf",
		"description": "Printf",
		"body": [
			"printf(\"$1\"$2);"
            
		]
	},
	"Task create": {
		"prefix": "task_create",
		"description": "Task template",
		"body": [
		  "#define  ${1/(.*)/${1:/upcase}/}_THREAD_STACK_SIZE      (${2|256,512,1024,2048|}u)",
		  "#define  ${1/(.*)/${1:/upcase}/}_THREAD_PRIORITY        (tskIDLE_PRIORITY + ${3:2}u) ",
		  "",
		  "static TaskHandle_t task_$1_hndl  = NULL;",
		  "",
		  "static void $1_task (void const *p_argument);",
		  "",
		  "// Create task $1.",
		  "if (NULL == task_$1_hndl)",
		  "{",
		  "    BaseType_t task_ret_val;",
		  "    task_ret_val = xTaskCreate((TaskFunction_t)$1_task, ",
		  "                                \"$1 task\", ",
		  "                                ${1/(.*)/${1:/upcase}/}_THREAD_STACK_SIZE,",
		  "                                NULL,",
		  "                                ${1/(.*)/${1:/upcase}/}_THREAD_PRIORITY, ",
		  "                                &task_$1_hndl);",
		  "",
		  "    if ((NULL == task_$1_hndl ) || (task_ret_val != pdPASS))",
		  "    {",
		  "        ${4:/* error code here */}",
		  "    }",
		  "}"
		]
	  },
	  "Timer": {
		"prefix": "timer_create",
		"body": [
		  "static TimerHandle_t $1_timer_hndl = NULL;",
		  "",
		  "static const uint32_t $1_timer_period_ms = ${2:<period in ms>}u;",
		  "",
		  "/**",
		  " * @brief Timer $1 Callback function.",
		  " * ",
		  " * @param p_arg - optional timer argument passed to the callback function.",
		  " */",
		  "static void $1_timer_cb (void *p_arg);",
		  "",
		  "// Create timer $1.",
		  "if (NULL == $1_timer_hndl)",
		  "{",
		  "    $1_timer_hndl = xTimerCreate(\"$1_timer\",",
		  "                                  ($1_timer_period_ms / portTICK_PERIOD_MS),",
		  "                                  ${3|pdTRUE,pdFALSE|}, NULL, ",
		  "                                  $1_timer_cb );",
		  "",
		  "    if (NULL == $1_timer_hndl )",
		  "    {",
		  "        ${4:/* Handle timer creation error.. */}",
		  "    }",
		  "}",
		  "",
		  "// Start timer $1.",
		  "if ($1_timer_hndl)",
		  "{",
		  "    if( xTimerStart($1_timer_hndl , 0 ) != pdPASS )",
		  "     {",
		  "         ${5:/* The timer could not be set into the Active state. */}",
		  "     }",
		  "}"
		],
		"description": "Timer"
	  },
	  "Queue Create": {
		"prefix": "queue_create",
		"body": [
		  "#define  ${1/(.*)/${1:/upcase}/}_QUEUE_LEN   (${2:10}u)",
		  "",
		  "static ${1/(.*)/${1:/lowcase}/}_queue = NULL;",
		  "",
		  "// Creating $1 queue.",
		  "if (NULL ==  ${1/(.*)/${1:/lowcase}/}_queue)",
		  "{",
		  "    ${1/(.*)/${1:/lowcase}/}_queue = xQueueCreate(${1/(.*)/${1:/upcase}/}_QUEUE_LEN, sizeof(${3:type_t}));",
		  "",
		  "    // Check if queue $1 is created successfully.",
		  "    if (NULL == ${1/(.*)/${1:/lowcase}/}_queue)",
		  "    {",
		  "        ${4:/* Queue error handler */}",
		  "    }",
		  "}"
		],
		"description": "Queue Create"
	  },
	  "Mutex Create": {
		"prefix": "mutex_create",
		"body": [
		  "static SemaphoreHandle_t ${1/(.*)/${1:/lowcase}/}_mutex = NULL;",
		  "",
		  "// Create ${1/(.*)/${1:/lowcase}/} mutex.",
		  "if (NULL == ${1/(.*)/${1:/lowcase}/}_mutex)",
		  "{",
		  "    ${1/(.*)/${1:/lowcase}/}_mutex = xSemaphoreCreateMutex();",
		  "",
		  "    // Check if ${1/(.*)/${1:/lowcase}/} mutex is created successfully.",
		  "    if (NULL == ${1/(.*)/${1:/lowcase}/}_mutex)",
		  "    {",
		  "        ${2:/* Mutex error handler */}",
		  "    }",
		  "}",
		  ""
		],
		"description": "Mutex Create"
	  }, 
	  "Semaphore Create": {
		"prefix": "semaphore_create, smphr_create",
		"body": [
		  "static SemaphoreHandle_t ${1/(.*)/${1:/lowcase}/}_smphr = NULL;",
		  "",
		  "// Create  ${1/(.*)/${1:/lowcase}/} semaphore.",
		  "if (NULL == ${1/(.*)/${1:/lowcase}/}_smphr)",
		  "{",
		  "    ${1/(.*)/${1:/lowcase}/}_smphr = xSemaphoreCreateBinary();",
		  "",
		  "    // Check if  ${1/(.*)/${1:/lowcase}/} semaphore is created successfully.",
		  "    if (NULL == ${1/(.*)/${1:/lowcase}/}_smphr)",
		  "    {",
		  "        ${2:/* Semaphore error handler */}",
		  "    }",
		  "}",
		  ""
		],
		"description": "Semaphore Create"
	  },
	  "Mutex take": {
		"prefix": "mutex_take",
		"body": [
		  "// Take ${1/(.*)/${1:/lowcase}/} Mutex.",
		  "if (NULL != ${1/(.*)/${1:/lowcase}/}_mutex)",
		  "{",
		  "    BaseType_t ${1/(.*)/${1:/lowcase}/}_mutex_ret = pdFAIL;",
		  "    ${1/(.*)/${1:/lowcase}/}_mutex_ret = xSemaphoreTake(${1/(.*)/${1:/lowcase}/}_mutex, ${2|portMAX_DELAY,1000u / portTICK_PERIOD_MS|});",
		  "",
		  "    if (pdFAIL == ${1/(.*)/${1:/lowcase}/}_mutex_ret)",
		  "    {",
		  "        ${3:/* Failed to take mutex. */}",
		  "    }",
		  "}",
		  ""
		],
		"description": "Mutex take"
	  },
	  "Semaphore take": {
		"prefix": "semaphore_take, smphr_take",
		"body": [
		  "// Take ${1/(.*)/${1:/lowcase}/} semaphore.",
		  "if (NULL != ${1/(.*)/${1:/lowcase}/}_smphr)",
		  "{",
		  "    BaseType_t ${1/(.*)/${1:/lowcase}/}_smphr_ret = pdFAIL;",
		  "    ${1/(.*)/${1:/lowcase}/}_smphr_ret = xSemaphoreTake(${1/(.*)/${1:/lowcase}/}_smphr, ${2|portMAX_DELAY,1000u / portTICK_PERIOD_MS|});",
		  "",
		  "    if (pdFAIL == ${1/(.*)/${1:/lowcase}/}_smphr_ret)",
		  "    {",
		  "        ${3:/* Failed to take semaphore. */}",
		  "    }",
		  "}",
		  ""
		],
		"description": "Semaphore take"
	  },
	  "Mutex give": {
		"prefix": "mutex_give",
		"body": [
		  "// Give ${1/(.*)/${1:/lowcase}/} Mutex.",
		  "if(NULL != ${1/(.*)/${1:/lowcase}/}_mutex)",
		  "{",
		  "    BaseType_t ${1/(.*)/${1:/lowcase}/}_mutex_ret = pdFAIL;",
		  "    ${1/(.*)/${1:/lowcase}/}_mutex_ret =  xSemaphoreGive(${1/(.*)/${1:/lowcase}/}_mutex);",
		  "",
		  "    if (pdFAIL == ${1/(.*)/${1:/lowcase}/}_mutex_ret)",
		  "    {",
		  "        ${2:/* Failed to give mutex. */}",
		  "    }",
		  "}",
		  ""
		],
		"description": "Mutex give"
	  },
	  "Semaphore give": {
		"prefix": "semaphore_give, smphr_give",
		"body": [
		  "// Give ${1/(.*)/${1:/lowcase}/} Semaphore.",
		  "if(NULL != ${1/(.*)/${1:/lowcase}/}_smphr)",
		  "{",
		  "    BaseType_t ${1/(.*)/${1:/lowcase}/}_smphr_ret = pdFAIL;",
		  "    ${1/(.*)/${1:/lowcase}/}_smphr_ret =  xSemaphoreGive(${1/(.*)/${1:/lowcase}/}_smphr);",
		  "",
		  "    if (pdFAIL == ${1/(.*)/${1:/lowcase}/}_smphr_ret )",
		  "    {",
		  "        ${2:/* Failed to give semaphore. */}",
		  "    }",
		  "}",
		  ""
		],
		"description": "Semaphore give"
	  }
}

